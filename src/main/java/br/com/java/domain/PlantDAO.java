	package br.com.java.domain;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

public class PlantDAO extends BaseDAO {

	// Method that gets the response from the DATABASE
	// And transform it into a Plant Object
	public Plant createPlant(ResultSet rs) throws SQLException {
		Plant p = new Plant();
		p.setId(rs.getLong("id"));
		p.setPlants(rs.getString("plant"));
		p.setDate(rs.getDate("date"));
		p.setSun(rs.getByte("sun"));
		p.setWaterTimes(rs.getInt("WaterTimes"));
		p.setWaterUnity(rs.getString("WaterUnity"));

		return p;
	}

	// Now a method to get a plant by its Id
	public Plant getPlantById(Long id) throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;
		try {
			conn = getConnection();
			stmt = conn.prepareStatement("SELECT * FROM garden where id=?");
			stmt.setLong(1, id);
			ResultSet rs = stmt.executeQuery();
			if (rs.next()) {
				Plant p = createPlant(rs);
				rs.close();
				return p;
			}
		} finally {
			if (stmt != null) {
				stmt.close();
			}
			if (conn != null) {
				conn.close();
			}
		}

		return null;
	}

	// Search on our data base by the name of the plant
	public List<Plant> findByName(String name) throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;
		List<Plant> pl = new ArrayList<Plant>();

		try {
			conn = getConnection();
			// Add LOWER and then toLower case so it wont be case sensitive
			stmt = conn.prepareStatement("SELECT * FROM garden WHERE LOWER(plant) LIKE ?");
			// Add "%"'s in case of the name be between other words
			stmt.setString(1, "%" + name.toLowerCase() + "%");
			ResultSet rs = stmt.executeQuery();
			
			// Handling multiple results
			while (rs.next()) {
				// The result wont return a Plant Object, so we first make it happen
				Plant p = createPlant(rs);
				// Now we can pass the resulting plant in his object format
				pl.add(p);
			}
			rs.close();
		} finally {
			if (conn != null) {
				conn.close();
			}
			if (stmt != null) {
				stmt.close();
			}
		}
		return pl;
	}

	// A method to return all the plants from the dataBase
	public List<Plant> getPlants() throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;
		List<Plant> pl = new ArrayList<Plant>();

		try {
			conn = getConnection();
			stmt = conn.prepareStatement("SELECT * FROM garden");
			ResultSet rs = stmt.executeQuery();
			while (rs.next()) {
				Plant p = createPlant(rs);
				pl.add(p);
			}
		} finally {
			if (conn != null) {
				conn.close();
			}
			if (stmt != null) {
				stmt.close();
			}
		}
		return pl;

	}

	
	// Method to read the autogenerated ID from a added plant
	public static Long getGeneratedId(Statement stmt) throws SQLException {
		ResultSet rs = stmt.getGeneratedKeys();
		if (rs.next()) {
			Long id = rs.getLong(1);
			return id;
		}
		return 0L;
	}

	// A Save/Update method
	public void savePlant(Plant p) throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			conn = getConnection();
			if (p.getId() == 0) {
				stmt = conn.prepareStatement(
						"INSERT INTO garden (plant, date, sun, WaterTimes, WaterUnity) VALUES (?,?,?,?,?)",
						Statement.RETURN_GENERATED_KEYS);
			} else {
				stmt = conn.prepareStatement(
						"UPDATE garden SET plant=?, date=?, sun=?, WaterTimes=?, WaterUnity=? WHERE id=?");
			}
			stmt.setString(1, p.getPlants());
			stmt.setDate(2, p.getDate());
			stmt.setByte(3, p.getSun());
			stmt.setInt(4, p.getWaterTimes());
			stmt.setString(5, p.getWaterUnity());

			// If it is a update we need to add the already existent id
			if (p.getId() != 0) {
				stmt.setLong(6, p.getId());
			}
			// Lets check if the update was successful
			int count = stmt.executeUpdate(); // if it returns nothing, count will be equals 0
			if (count == 0)
				throw new SQLException("Error in inserting the plant");

			// if the insertion was fine, we can read the autoIncremented Id
			if (p.getId() == null) {
				// Now we will use the method we created before
				Long id = getGeneratedId(stmt);
				p.setId(id);
			}

		} finally {
			if (conn != null) {
				conn.close();
			}
			if (stmt != null) {
				stmt.close();
			}
		}

	}

	// A delete method, by the plant id
	public boolean deletePlant(Long id) throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;

		try {
			conn = getConnection();
			stmt = conn.prepareStatement("DELETE FROM garden WHERE id = ?");
			stmt.setLong(1, id);
			// lets execute the query and analyze its return
			int count = stmt.executeUpdate();
			boolean ok = count > 0 ? true : false;
			return ok;
		} finally {
			if (conn != null) {
				conn.close();
			}
			if (stmt != null) {
				stmt.close();
			}
		}

	}

	//A method to return the next auto_incremented ID
	public long getNextID() throws SQLException {
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			conn = getConnection();
			stmt = conn.prepareStatement("SELECT Auto_increment FROM information_schema.tables WHERE table_schema = DATABASE()");
			ResultSet rs = stmt.executeQuery();
			rs.next();
			long id = rs.getLong(1);
			return id;
		}catch (SQLException e) {
			System.out.println(e);
			return 0;
		}finally {
			if(conn != null) {
				conn.close();
			}
			if(stmt != null) {
				stmt.close();
			}
		}
	}
}
